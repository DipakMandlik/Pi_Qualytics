/**
 * Antigravity Investigation Controller
 * Manages root cause analysis sessions with AI-generated SQL.
 * 
 * Flow: Schema Introspection → AI SQL Generation → Validation → Execution
 * Rule: NO hardcoded SQL - all generated by Gemini after reading schema
 */

import { snowflakePool, executeQuery } from '@/lib/snowflake';
import { getServerConfig } from '@/lib/server-config';
import { introspectSchema, SchemaRegistry } from './schema-reader';
import { generateSQL, INVESTIGATION_QUESTIONS, GeneratedSQL } from './sql-generator';

export interface InvestigationSession {
  sessionId: string;
  assetId: string;
  insightId?: string;
  insightType: string;
  status: 'ACTIVE' | 'COMPLETED' | 'ABANDONED';
  startedAt: string;
  schemaRegistry?: SchemaRegistry;
}

export interface GuidedQuestion {
  key: string;
  label: string;
  description: string;
  chartType: 'LINE' | 'BAR' | 'AREA' | 'DAG' | 'NONE';
}

// Cache for schema registry
let schemaCache: { registry: SchemaRegistry; timestamp: number } | null = null;
const SCHEMA_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

/**
 * Gets or refreshes the schema registry.
 */
async function getSchemaRegistry(database: string): Promise<SchemaRegistry> {
  const now = Date.now();

  if (schemaCache && (now - schemaCache.timestamp) < SCHEMA_CACHE_TTL) {
    return schemaCache.registry;
  }

  console.log('[ANTIGRAVITY] Refreshing schema registry...');
  const registry = await introspectSchema(database, ['DQ_METRICS', 'DQ_CONFIG', 'DB_METRICS']);
  schemaCache = { registry, timestamp: now };

  return registry;
}

/**
 * Starts a new investigation session.
 * Step 1: Introspect schema (mandatory before ANY SQL generation)
 */
export async function startInvestigation(
  assetId: string,
  insightType: string,
  insightId?: string,
  initiatedBy?: string
): Promise<{ session: InvestigationSession; questions: GuidedQuestion[] }> {
  const config = getServerConfig();
  if (!config) {
    throw new Error('No Snowflake connection available.');
  }

  const connection = await snowflakePool.getConnection(config);
  const sessionId = crypto.randomUUID();

  // STEP 1: Schema introspection (MANDATORY)
  const [database] = assetId.split('.');
  let schemaRegistry: SchemaRegistry = {};

  try {
    schemaRegistry = await getSchemaRegistry(database || 'DATA_QUALITY_DB');
    console.log(`[ANTIGRAVITY] Schema loaded: ${Object.keys(schemaRegistry).length} schemas`);
  } catch (e) {
    console.warn('[ANTIGRAVITY] Could not load schema:', e);
  }

  // Insert session record
  try {
    const sql = `
      INSERT INTO DATA_QUALITY_DB.DB_METRICS.DQ_INVESTIGATION_SESSIONS (
        SESSION_ID, ASSET_ID, INSIGHT_ID, INSIGHT_TYPE, INITIATED_BY
      ) VALUES (?, ?, ?, ?, ?)
    `;
    await new Promise<void>((resolve, reject) => {
      connection.execute({
        sqlText: sql,
        binds: [sessionId, assetId.toUpperCase(), insightId || null, insightType, initiatedBy || 'USER'],
        complete: (err: any) => {
          if (err) console.warn('[INVESTIGATION] Session record error:', err.message);
          resolve();
        },
      });
    });
  } catch (e) {
    console.warn('[INVESTIGATION] Could not create session record');
  }

  // Get questions for this insight type (questions are predefined, SQL is NOT)
  const questionSet = INVESTIGATION_QUESTIONS[insightType.toUpperCase() as keyof typeof INVESTIGATION_QUESTIONS]
    || INVESTIGATION_QUESTIONS['QUALITY'];

  const session: InvestigationSession = {
    sessionId,
    assetId: assetId.toUpperCase(),
    insightId,
    insightType: insightType.toUpperCase(),
    status: 'ACTIVE',
    startedAt: new Date().toISOString(),
    schemaRegistry,
  };

  console.log(`[INVESTIGATION] Started session ${sessionId} for ${assetId}`);
  return { session, questions: questionSet };
}

/**
 * Executes a guided question using AI-generated SQL.
 * The SQL is generated by Gemini based on the schema - NOT hardcoded.
 */
export async function executeQuestion(
  sessionId: string,
  assetId: string,
  questionKey: string,
  questionLabel: string,
  insightType: string
): Promise<{
  questionKey: string;
  chartType: string;
  sql: string;
  sqlGenerated: boolean;
  data: any[];
  columns: string[];
  validationErrors: string[];
}> {
  const config = getServerConfig();
  if (!config) {
    throw new Error('No Snowflake connection available.');
  }

  const connection = await snowflakePool.getConnection(config);

  // STEP 1: Get schema registry
  const [database] = assetId.split('.');
  const schemaRegistry = await getSchemaRegistry(database || 'DATA_QUALITY_DB');

  // Find the question definition
  const questionSet = INVESTIGATION_QUESTIONS[insightType.toUpperCase() as keyof typeof INVESTIGATION_QUESTIONS]
    || INVESTIGATION_QUESTIONS['QUALITY'];
  const question = questionSet.find(q => q.key === questionKey);

  if (!question) {
    throw new Error(`Unknown question: ${questionKey}`);
  }

  // STEP 2: Generate SQL using AI (with fallback to templates)
  const fullQuestion = `${question.label} ${question.description} for asset ${assetId}`;
  const generatedSQL = await generateSQL(fullQuestion, assetId, schemaRegistry, questionKey);

  if (!generatedSQL.isValid || !generatedSQL.sql) {
    console.warn(`[INVESTIGATION] Invalid SQL generated:`, generatedSQL.validationErrors);
    return {
      questionKey,
      chartType: question.chartType,
      sql: generatedSQL.sql || 'Generation failed',
      sqlGenerated: true,
      data: [],
      columns: [],
      validationErrors: generatedSQL.validationErrors,
    };
  }

  // STEP 3: Execute validated SQL
  let data: any[] = [];
  let columns: string[] = [];

  try {
    const result = await executeQuery(connection, generatedSQL.sql);
    columns = result.columns || [];
    data = result.rows.map((row: any[]) => {
      const obj: Record<string, any> = {};
      columns.forEach((col, idx) => {
        obj[col] = row[idx];
      });
      return obj;
    });
    console.log(`[INVESTIGATION] Executed AI-generated SQL: ${data.length} rows`);
  } catch (e: any) {
    console.error(`[INVESTIGATION] SQL execution error:`, e.message);
    return {
      questionKey,
      chartType: question.chartType,
      sql: generatedSQL.sql,
      sqlGenerated: true,
      data: [],
      columns: [],
      validationErrors: [`Execution error: ${e.message}`],
    };
  }

  // STEP 4: Store artifact
  try {
    const artifactSql = `
      INSERT INTO DATA_QUALITY_DB.DB_METRICS.DQ_INVESTIGATION_ARTIFACTS (
        SESSION_ID, ARTIFACT_TYPE, QUESTION_KEY, CHART_TYPE, ARTIFACT_PAYLOAD
      ) VALUES (?, 'CHART', ?, ?, PARSE_JSON(?))
    `;
    await new Promise<void>((resolve) => {
      connection.execute({
        sqlText: artifactSql,
        binds: [sessionId, questionKey, question.chartType, JSON.stringify({
          sql: generatedSQL.sql,
          rowCount: data.length,
          aiGenerated: true
        })],
        complete: () => resolve(),
      });
    });
  } catch { /* Ignore storage errors */ }

  return {
    questionKey,
    chartType: question.chartType,
    sql: generatedSQL.sql,
    sqlGenerated: true,
    data,
    columns,
    validationErrors: [],
  };
}

/**
 * Gets available questions for an insight type.
 */
export function getQuestionsForType(insightType: string): GuidedQuestion[] {
  return INVESTIGATION_QUESTIONS[insightType.toUpperCase() as keyof typeof INVESTIGATION_QUESTIONS]
    || INVESTIGATION_QUESTIONS['QUALITY'];
}
